#!/usr/bin/env bash
# shellcheck disable=SC1090

#/ command: stubbs:add-option: "add a command option"
#/ usage: rerun stubbs:add-option [ --arg <true>]  --command|-c <> [ --default|-d <>]  --description <> [ --export <false>] [ --long <>]  --module|-m <>  --option|-o <> [ --required <false>] [ --short <>] 
#/ rerun-variables: RERUN, RERUN_VERSION, RERUN_MODULES, RERUN_MODULE_DIR
#/ option-variables: ARG COMMAND DEFAULT DESCRIPTION EXPORT LONG MODULE OPTION REQUIRED SHORT

. "$RERUN_MODULE_DIR/lib/functions.sh" 'add-option' || { 
  echo >&2 "Failed loading function library." ; exit 1 ; 
}

set -o errexit -o nounset -o pipefail

rerun_options_parse "$@"

# Command implementation
# ----------------------

# - - -

#
# functions
#
parse_command_name_for_module() {
  local command_name="$1"
  # Parse if command is named "module:command"
  local regex='([^:]+)(:)([^:]+)'
  if [[ $command_name =~ $regex ]]; then
    MODULE=${BASH_REMATCH[1]}
    COMMAND=${BASH_REMATCH[3]}
  fi
  
  return 0
}

quote_if_whitespace_string() {
    local string="$*"
    if [[ $string = *[[:space:]]* ]] 
    then printf "\"%s\"" "$string"
    else printf "%s" "$string"
    fi
}

#
# execution
#

parse_command_name_for_module "$COMMAND"

RERUN_MODULE_HOME_DIR=$(rerun_module_exists "$MODULE")

# check the chosen module exists
[[ ! -f $RERUN_MODULE_HOME_DIR/metadata ]] && rerun_option_error "module not found: $MODULE"

# check option name for whitespace
[[ "$OPTION" = *[[:space:]]* ]] && {
    rerun_die 2 "option name cannot contain whitespace: \"$OPTION\""
}

# If short is specified, check it's not already used.
[[ -n "${SHORT:-}" ]] && {
    options=$(stubbs_options_with_short "$RERUN_MODULE_HOME_DIR" "$SHORT")
    [[ -n "${options:-}" && "$options" != "$OPTION" ]] && {
        rerun_die "-${SHORT} already used by option: $options"
    }
}

# Generate metadata for new option
mkdir -p  "$RERUN_MODULE_HOME_DIR/options/$OPTION"
(
    cat <<EOF
# option metadata
# generated by stubbs:add-option
# $(date)
NAME=$OPTION
DESCRIPTION=$(quote_if_whitespace_string "$DESCRIPTION")
ARGUMENTS=${ARG:-true}
REQUIRED=${REQUIRED:-true}
SHORT=${SHORT:-}
LONG=${LONG:-$OPTION}
DEFAULT=$(quote_if_whitespace_string "$DEFAULT")
EXPORT=$EXPORT

EOF
) > "$RERUN_MODULE_HOME_DIR/options/$OPTION/metadata" || {
    rerun_die "Failed generating $OPTION option metadata"
}
rerun_log info "Wrote option metadata: $RERUN_MODULE_HOME_DIR/options/$OPTION/metadata"

COMMAND_LIST=( ${COMMAND//,/ } )
for cmd in ${COMMAND_LIST[*]}
do
  #
  # Verify this command exists
  #
  [ ! -d "$RERUN_MODULE_HOME_DIR/commands/$cmd" ] && {
      echo >&2 "command not found: \"$MODULE:$cmd\".... skipping."
      continue
  }
  #
  # Update the command metadata.
  #
  command_options=( $(rerun_options "$RERUN_MODULES" "$MODULE" "$cmd") )
  # Add this OPTION to the list if it is not yet assigned.
  rerun_list_contains "$OPTION" "${command_options[@]:-}" || {
      if [[ -z "${command_options:-}" ]]
      then command_options=( $OPTION ) 
      else command_options=( ${command_options[*]} $OPTION )
      fi
  }
  command_metadata=$RERUN_MODULE_HOME_DIR/commands/$cmd/metadata
  stubbs_command_options_write \
      "$RERUN_MODULE_HOME_DIR" "$cmd" \
      "${command_options[*]}" || rerun_die "Failed generating command metadata"
  rerun_log info "Updated command metadata: $command_metadata"
  #
  # Generate option parser script.
  #
  .  "$RERUN_MODULE_DIR/lib/stub/bash/metadata" || {
      rerun_die "error reading  $RERUN_MODULE_DIR/lib/stub/bash/metadata "
  }
  [ -z "$OPTIONS_GENERATOR" ] && {
      rerun_die "required metadata not found: OPTIONS_GENERATOR"
  }
  [ -z "$OPTIONS_SCRIPT" ] && {
     rerun_die "required metadata not found: OPTIONS_SCRIPT"
  }
  options_parser=$RERUN_MODULE_HOME_DIR/commands/$cmd/$OPTIONS_SCRIPT
  "$RERUN_MODULE_DIR/lib/stub/bash/$OPTIONS_GENERATOR" \
      $(dirname "$RERUN_MODULE_HOME_DIR") "$MODULE" "$cmd" > "$options_parser" || {
      rerun_die "Failed generating options parser."
  }
  rerun_log info "Generated options parser: $options_parser"
  #
  # Update the command script header to give it the updated
  # variable summary and usage info.
  [ -z "$TEMPLATE_COMMAND_SCRIPT" ] && {
      rerun_die "required metadata not found: TEMPLATE_COMMAND_SCRIPT"
  }
  command_script=$RERUN_MODULE_HOME_DIR/commands/$cmd/$(basename $TEMPLATE_COMMAND_SCRIPT)
  if [ -f "$command_script" ]
  then
      stubbs_script_header \
          "$RERUN_MODULE_HOME_DIR" "$cmd" > "$command_script.$$" || {
          rerun_die "Error updating command script header"
      }
      mv "$command_script.$$" "$command_script" || {
          rerun_die "Error updating command script header"
      }
      chmod +x "$command_script" || rerun_die "Failed setting execute bit on command script."
      rerun_log info "Updated command script header: $command_script"
  fi
done

# - - -

# Done. Exit with last command exit status.
exit $?
