const char* expectsrc = 
  "--[[\n"
  " * expectsrc.lua\n"
  " *\n"
  " * expect function for lpty\n"
  " *\n"
  " * Gunnar ZÃ¶tl <gz@tset.de>, 2010-2015\n"
  " * Released under MIT/X11 license. See file LICENSE for details.\n"
  "--]]\n"
  "\n"
  "-- this is passed in from luaopen_lpty() \n"
  "local gettime = ...\n"
  "\n"
  "local unpack = unpack or table.unpack\n"
  "\n"
  "local function err(msg, throw)\n"
  "	if throw then\n"
  "		error(msg, 3)\n"
  "	end\n"
  "	return nil, msg\n"
  "end\n"
  "\n"
  "local function expect(p, what, plain, tmout)\n"
  "	\n"
  "	local throw = p:getflags().throw_errors\n"
  "\n"
  "	local res = \'\'\n"
  "	local found, timedout = nil, false\n"
  "	local start = gettime()\n"
  "	local rem_tmout = tmout\n"
  "	while not found and not timedout do\n"
  "		local r, why = p:readline(false, rem_tmout)\n"
  "		if r ~= nil then\n"
  "			res = res .. \"\\n\" .. r\n"
  "			-- try match on current line first, and if that fails, on entire buffer\n"
  "			local all = { string.find(r, what, 1, plain) }\n"
  "			if all[1] == nil then\n"
  "				all = { string.find(res, what, 1, plain) }\n"
  "				r = res\n"
  "			end\n"
  "			local first, last, capture = unpack(all)\n"
  "			if first then\n"
  "				if capture then\n"
  "					found = { unpack(all, 3) }\n"
  "				else\n"
  "					found = { string.sub(r, first, last) }\n"
  "				end\n"
  "			end\n"
  "		else\n"
  "			if why then\n"
  "				return err(\'lpty expect failed: \' .. why, throw)\n"
  "			else\n"
  "				local what, code = p:exitstatus()\n"
  "				if what then\n"
  "					return err(\'lpty expect failed: child process terminated: \' .. tostring(what) .. \' \' ..tostring(code), throw)\n"
  "				end\n"
  "			end\n"
  "		end\n"
  "\n"
  "		if tmout and not found then\n"
  "			local now = gettime()\n"
  "			-- we don\'t time out while we actually read stuff\n"
  "			if r == nil and now - tmout >= start then\n"
  "				timedout = true\n"
  "			-- also we don\'t update the remaining timeout value to become negative\n"
  "			else\n"
  "				rem_tmout = tmout + start - now\n"
  "				if rem_tmout < 0 then rem_tmout = 0 end\n"
  "			end\n"
  "		end\n"
  "	end\n"
  "	if found then\n"
  "		return unpack(found)\n"
  "	end\n"
  "	return nil\n"
  "end\n"
  "\n"
  "return expect\n"
;
